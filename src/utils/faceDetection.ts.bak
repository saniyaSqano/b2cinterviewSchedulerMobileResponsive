/**
 * Face Detection Utility
 * 
 * This module provides face detection functionality using TensorFlow.js and BlazeFace.
 * It handles face presence tracking and provides callbacks for face lost/returned events.
 */

import * as tf from '@tensorflow/tfjs';
import * as blazeface from '@tensorflow-models/blazeface';

// Model instance
let model: blazeface.BlazeFaceModel | null = null;

// Face detection state
type FaceDetectionState = {
  isModelLoading: boolean;
  isModelLoaded: boolean;
  facePresent: boolean;
  lastFaceDetectionTime: number | null;
  faceLostTimer: NodeJS.Timeout | null;
  consecutiveNoFaceFrames: number;
  consecutiveFaceFrames: number;
  faceLostThreshold: number;
  onFaceLost: ((duration: number) => void) | null;
  onFaceReturned: (() => void) | null;
};

// Global state object
const state: FaceDetectionState = {
  isModelLoading: false,
  isModelLoaded: false,
  facePresent: true,
  lastFaceDetectionTime: null,
  faceLostTimer: null,
  consecutiveNoFaceFrames: 0,
  consecutiveFaceFrames: 0,
  faceLostThreshold: 3000, // Default: 3 seconds
  onFaceLost: null,
  onFaceReturned: null
};

/**
 * Initialize the BlazeFace model for face detection
 */
export const initFaceDetection = async (): Promise<void> => {
  if (state.isModelLoading) {
    console.log('Face detection model is already being initialized');
    return;
  }
  
  if (state.isModelLoaded && model) {
    console.log('Face detection model is already loaded');
    return;
  }
  
  try {
    state.isModelLoading = true;
    console.log('Initializing face detection model...');
    
    // Try to use WebGL backend for better performance
    try {
      console.log('Setting up WebGL backend...');
      await tf.setBackend('webgl');
      console.log('Using WebGL backend:', tf.getBackend());
    } catch (error) {
      console.warn('Failed to set WebGL backend, falling back to CPU:', error);
      await tf.setBackend('cpu');
      console.log('Using CPU backend:', tf.getBackend());
    }
    
    // Load the BlazeFace model
    console.log('Loading BlazeFace model...');
    model = await blazeface.load();
    state.isModelLoaded = true;
    console.log('BlazeFace model loaded successfully');
  } catch (error) {
    console.error('Failed to initialize face detection:', error);
    throw error;
  } finally {
    state.isModelLoading = false;
  }
};

/**
 * Configure face tracking settings and callbacks
 * @param threshold Time in ms before triggering face lost event
 * @param faceLostCallback Callback when face is lost for threshold duration
 * @param faceReturnedCallback Callback when face returns to frame
 */
export const configureFaceTracking = (
  threshold: number = 3000,
  faceLostCallback: ((duration: number) => void) | null = null,
  faceReturnedCallback: (() => void) | null = null
): void => {
  // Update state with new configuration
  state.faceLostThreshold = threshold;
  state.onFaceLost = faceLostCallback;
  state.onFaceReturned = faceReturnedCallback;
  
  // Reset tracking state
  state.facePresent = true;
  state.lastFaceDetectionTime = Date.now();
  state.consecutiveNoFaceFrames = 0;
  state.consecutiveFaceFrames = 0;
  
  // Clear any existing timer
  if (state.faceLostTimer) {
    console.log('Clearing existing face lost timer');
    clearTimeout(state.faceLostTimer);
    state.faceLostTimer = null;
  }
  
  console.log(`Face tracking configured: threshold=${threshold}ms, callbacks set:`, {
    faceLostCallbackSet: !!faceLostCallback,
    faceReturnedCallbackSet: !!faceReturnedCallback
  });
  
  // Test callbacks to ensure they're working
  if (faceLostCallback) {
    console.log('Testing face lost callback...');
    setTimeout(() => {
      try {
        // Call with 0 duration to test
        faceLostCallback(0);
        console.log('Face lost callback test successful');
      } catch (error) {
        console.error('Error in face lost callback test:', error);
      }
    }, 100);
  }
};

/**
 * Reset face tracking state
 */
export const resetFaceTracking = (): void => {
  console.log('Resetting face tracking state');
  
  // Reset state
  state.facePresent = true;
  state.lastFaceDetectionTime = null;
  state.consecutiveNoFaceFrames = 0;
  state.consecutiveFaceFrames = 0;
  
  // Clear any existing timer
  if (state.faceLostTimer) {
    console.log('Clearing face lost timer during reset');
    clearTimeout(state.faceLostTimer);
    state.faceLostTimer = null;
  }
  
  // Clear callbacks
  state.onFaceLost = null;
  state.onFaceReturned = null;
};

/**
 * Handle face presence changes
 * @param faceDetected Whether a face is currently detected
 */
const handleFacePresenceChange = (faceDetected: boolean): void => {
  const currentTime = Date.now();
  
  console.log(`Face detection status: ${faceDetected ? 'DETECTED' : 'NOT DETECTED'}, current state: ${state.facePresent ? 'present' : 'absent'}`);
  
  // Update consecutive frame counters
  if (faceDetected) {
    state.consecutiveFaceFrames++;
    state.consecutiveNoFaceFrames = 0;
    console.log(`Consecutive frames with face: ${state.consecutiveFaceFrames}`);
  } else {
    state.consecutiveNoFaceFrames++;
    state.consecutiveFaceFrames = 0;
    console.log(`Consecutive frames without face: ${state.consecutiveNoFaceFrames}`);
  }
  
  // Require at least 3 consecutive frames without a face before considering it lost
  const isReallyLost = state.consecutiveNoFaceFrames >= 3;
  
  // Require at least 2 consecutive frames with a face before considering it returned
  const isReallyReturned = state.consecutiveFaceFrames >= 2;
  
  // If face was not present before but is now reliably detected
  if (!state.facePresent && faceDetected && isReallyReturned) {
    console.log('Face RETURNED to frame - confirmed');
    state.facePresent = true;
    state.lastFaceDetectionTime = currentTime;
    
    // Clear any pending face lost timer
    if (state.faceLostTimer) {
      console.log('Clearing pending face lost timer');
      clearTimeout(state.faceLostTimer);
      state.faceLostTimer = null;
    }
    
    // Call the face returned callback if provided
    if (state.onFaceReturned) {
      console.log('Calling onFaceReturned callback');
      try {
        state.onFaceReturned();
      } catch (error) {
        console.error('Error in onFaceReturned callback:', error);
      }
    } else {
      console.log('No onFaceReturned callback provided');
    }
  }
  // If face was present before but is now reliably lost
  else if (state.facePresent && !faceDetected && isReallyLost) {
    console.log('Face LOST from frame - starting timer');
    
    // Start a timer to trigger the face lost event after the threshold
    if (state.onFaceLost) {
      console.log(`Starting face lost timer for ${state.faceLostThreshold}ms`);
      
      // Clear any existing timer first
      if (state.faceLostTimer) {
        clearTimeout(state.faceLostTimer);
      }
      
      // Set a new timer
      state.faceLostTimer = setTimeout(() => {
        console.log('Face lost timer triggered');
        
        if (state.onFaceLost) {
          const lostDuration = currentTime - (state.lastFaceDetectionTime || currentTime);
          console.log(`Face lost for ${lostDuration}ms, calling onFaceLost callback`);
          
          // Update state before calling callback
          state.facePresent = false;
          
          try {
            state.onFaceLost(Math.round(lostDuration / 1000)); // Convert to seconds
          } catch (error) {
            console.error('Error in onFaceLost callback:', error);
          }
        }
      }, state.faceLostThreshold);
    } else {
      console.log('No onFaceLost callback provided');
    }
  }
  // If face is still detected, update the last detection time
  else if (faceDetected) {
    // Face is still present, update the last detection time
    state.lastFaceDetectionTime = currentTime;
  }
};

/**
 * Detect faces in a video element
 * @param videoElement HTML video element to detect faces in
 * @returns Object with detection results
 */
export const detectFaces = async (videoElement: HTMLVideoElement): Promise<{
  faceCount: number;
  noFaceDetected: boolean;
  multipleFacesDetected: boolean;
  predictions: blazeface.NormalizedFace[] | null;
}> => {
  // Ensure TensorFlow backend is initialized
  if (!tf.getBackend()) {
    console.warn('TensorFlow backend not initialized. Setting up WebGL...');
    try {
      await tf.setBackend('webgl');
      console.log('TensorFlow backend initialized:', tf.getBackend());
    } catch (err) {
      console.warn('WebGL backend failed, trying CPU:', err);
      try {
        await tf.setBackend('cpu');
        console.log('TensorFlow CPU backend initialized:', tf.getBackend());
      } catch (cpuErr) {
        console.error('Failed to initialize any TensorFlow backend:', cpuErr);
        return {
          faceCount: 0,
          noFaceDetected: true,
          multipleFacesDetected: false,
          predictions: null,
        };
      }
    }
  }

  // Ensure model is loaded
  if (!model) {
    console.warn('Face detection model not loaded. Initializing...');
    try {
      await initFaceDetection();
      
      // If model still not loaded, return early
      if (!model) {
        console.error('Failed to initialize face detection model');
        return {
          faceCount: 0,
          noFaceDetected: true,
          multipleFacesDetected: false,
          predictions: null,
        };
      }
    } catch (error) {
      console.error('Error initializing face detection:', error);
      return {
        faceCount: 0,
        noFaceDetected: true,
        multipleFacesDetected: false,
        predictions: null,
      };
    }
  }

  // Check video element
  if (!videoElement) {
    console.error('Video element is null or undefined');
    return {
      faceCount: 0,
      noFaceDetected: true,
      multipleFacesDetected: false,
      predictions: null,
    };
  }
  
  if (videoElement.readyState < 2) { // HAVE_CURRENT_DATA or higher
    console.warn('Video element not ready for face detection, state:', videoElement.readyState);
    return { faceCount: 0, noFaceDetected: true, multipleFacesDetected: false, predictions: null };
  }

  try {
    console.log('Detecting faces on video element...');
    
    // Ensure model is loaded
    if (!model) {
      console.log('Face detection model not initialized, initializing now...');
      await initFaceDetection();
      if (!model) {
        console.error('Failed to initialize face detection model');
        return {
          faceCount: 0,
          noFaceDetected: true,
          multipleFacesDetected: false,
          predictions: null,
        };
      }
    }
    
    // Create a canvas element to capture the current frame
    const canvas = document.createElement('canvas');
    canvas.width = videoElement.videoWidth || 640;
    canvas.height = videoElement.videoHeight || 480;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      console.error('Failed to get canvas context');
      return {
        faceCount: 0,
        noFaceDetected: true,
        multipleFacesDetected: false,
        predictions: null,
      };
    }
    
    // Draw the current frame from the video to the canvas
    ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
    
    // Detect faces in the frame
    console.log('Running face estimation on video frame...');
    const predictions = await model.estimateFaces(canvas, false);
    
    // Calculate results
    const faceCount = predictions.length;
    const noFaceDetected = faceCount === 0;
    const multipleFacesDetected = faceCount > 1;
    
    console.log('Face detection results:', { faceCount, noFaceDetected, multipleFacesDetected });
    
    // Update face presence tracking - this is critical for the face lost detection
    handleFacePresenceChange(faceCount > 0);
    
    if (predictions.length > 0) {
      // Face detected - log first face position
      const firstFace = predictions[0];
      console.log(`Face detected at: (${firstFace.topLeft}, ${firstFace.bottomRight})`);
    } else {
      console.log('No faces detected in this frame');
    }
    
    return {
      faceCount,
      noFaceDetected,
      multipleFacesDetected,
      predictions,
    };
  } catch (error) {
    console.error('Error during face detection:', error);
    return {
      faceCount: 0,
      noFaceDetected: true,
      multipleFacesDetected: false,
      predictions: null,
    };
  }
};
